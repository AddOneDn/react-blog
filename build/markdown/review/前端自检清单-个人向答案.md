# 前端自检清单-个人向答案

在掘金上看到一篇文章[一名【合格】前端工程师的自检清单](https://juejin.im/post/5cc1da82f265da036023b628#heading-2)，于是准备在这里把自己的答案整理出来

# 一. JavaScript基础

## 变量和类型

### JavaScript规定了几种语言类型？

共有6种基本类型：[string](https://developer.mozilla.org/en-US/docs/Glossary/string)，[number](https://developer.mozilla.org/en-US/docs/Glossary/number)，[boolean](https://developer.mozilla.org/en-US/docs/Glossary/boolean)，[null](https://developer.mozilla.org/en-US/docs/Glossary/null)，[undefined](https://developer.mozilla.org/en-US/docs/Glossary/undefined)，[symbol](https://developer.mozilla.org/en-US/docs/Glossary/symbol) ([ECMAScript](https://developer.mozilla.org/en-US/docs/Glossary/ECMAScript) 2015新增)

多数情况下，基本类型直接代表了最底层的语言实现。

所有基本类型的值都是**不可改变**的。但需要注意的是，基本类型本身和一个赋值为基本类型的变量的区别。变量会被赋予一个新值，而原值不能像数组、对象以及函数那样被改变。

### JavaScript对象的底层数据结构是什么?

在V8中，对象主要由三个指针构成，分别是：

- 隐藏类(Hidden Class)：描述对象结构
- Property：存放对象属性，无法索引
- Element：存放对象属性，可以索引

其中属性有三种不同存储方式：

- 对象内属性(In-object)：保存在对象本身，提供最快的访问速度
- 快属性(fast)：比内属性多一次寻址时间
- 慢属性(slow)：将属性的完整结构存储，速度最慢

详细的建议看看这篇文章[V8 是怎么跑起来的 —— V8 中的对象表示](https://juejin.im/post/5cc7dc5af265da038d0b514d)

### Symbol类型在实际开发中的应用

 **symbol** 是一种原始数据类型，该类型的性质在于这个类型的值可以用来**创建匿名的对象属性**。该数据类型通常被**用作一个对象属性的键值**——当你想让它是私有的时候。

- Symbol 值通过 Symbol 函数生成，使用 typeof，结果为 "symbol"
- Symbol 函数前不能使用 new 命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象
- s instanceof Symbol() 的结果为 false
- Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分
- 如果 Symbol 的参数是一个对象，就会调用该对象的 toString 方法，将其转为字符串，然后才生成一个 Symbol 值
- Symbol 函数的参数只是表示对当前 Symbol 值的描述，相同参数的 Symbol 函数的返回值是不相等的
- Symbol 值不能与其他类型的值进行运算，会报错。
- Symbol 值可以显式转为字符串(String(s) or s.toString())
- Symbol 值可以作为标识符，用于对象的属性名，可以保证不会出现同名的属性
- 如果我们希望使用同一个 Symbol 值，可以使用 Symbol.for。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值
- Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key

### 实现一个Symbol

```javascript
(function() {
    var root = this;

    var generateName = (function(){
        var postfix = 0;
        return function(descString){
            postfix++;
            return '@@' + descString + '_' + postfix
        }
    })()

    var SymbolPolyfill = function Symbol(description) {

        if (this instanceof SymbolPolyfill) throw new TypeError('Symbol is not a constructor');

        var descString = description === undefined ? undefined : String(description)

        var symbol = Object.create({
            toString: function() {
                return this.__Name__;
            },
            valueOf: function() {
                return this;
            }
        })

        Object.defineProperties(symbol, {
            '__Description__': {
                value: descString,
                writable: false,
                enumerable: false,
                configurable: false
            },
            '__Name__': {
                value: generateName(descString),
                writable: false,
                enumerable: false,
                configurable: false
            }
        });

        return symbol;
    }

    var forMap = {};

    Object.defineProperties(SymbolPolyfill, {
        'for': {
            value: function(description) {
                var descString = description === undefined ? undefined : String(description)
                return forMap[descString] ? forMap[descString] : forMap[descString] = SymbolPolyfill(descString);
            },
            writable: true,
            enumerable: false,
            configurable: true
        },
        'keyFor': {
            value: function(symbol) {
                for (var key in forMap) {
                    if (forMap[key] === symbol) return key;
                }
            },
            writable: true,
            enumerable: false,
            configurable: true
        }
    });

    root.SymbolPolyfill = SymbolPolyfill;

})()
```

### JavaScript 中的变量在内存中的具体存储形式

**存储方式：**

- 基本类型：栈内存
- 引用类型：实际上是指针，指针保存在栈中，但指针指向的对象保存在堆内存中

**访问方式：**

- 基本类型：按值访问，读写的是它们实际保存的值
- 引用类型：按引用访问，读写它们时需要从栈中读取内存地址，然后找到保存在堆内存中的值

### 基本类型对应的内置对象，以及他们之间的装箱拆箱操作

常见内置对象十个：string，number，bool，math，Date， RegExp，error，function，obj，global

### 理解值类型和引用类型

基本类型(值类型)：Number，String，Boolean，Null，Undefined，Symbol

引用类型：Object，Array，Date，RegExp，Function

区别：

1. 值类型：
   - 占用空间固定，保存在栈中
   - 保存与复制的是值本身
   - 使用typeof检测数据的类型
   - 比较是值的比较
2. 引用类型：
   - 占用空间不固定，保存在堆中
   - 保存与赋值的是指向对象的指针，该指针保存在栈中
   - 使用 new 构造出的对象时引用型
   - 引用类型的比较是引用的比较

### null 与 undefined 的区别

1. 定义

null 是 javascript 的关键字，表示一个特殊值，常用来描述"空值"，typeof 运算返回"object"，所以可以将 null 认为是一个特殊的对象值，含义是"非对象"。

undefined 是预定义的全局变量，他的值就是"未定义"， typeof 运算返回 "undefined"

2. 转义

转换成 Boolean 时均为 false，转换成 Number 时有所不同

```javascript
!!(null); // false
!!(undefined); // false
Number(null); // 0
Number(undefined); // NaN

null == undefined; //true
null === undefined; //false
```

3. 判定

```javascript
isNull = function (obj) {
  return obj === null;
}
isUndefined = function (obj) {
  return obj === void 0;
}
```

4. 用法

null 常用来定义一个空值。

undefined 典型用法是：

1. 变量被声明了，但没有赋值时，就等于 undefined。
2. 调用函数时，应该提供的参数没有提供，该参数等于 undefined。
3. 对象没有赋值的属性，该属性的值为 undefined。
4. 函数没有返回值时，默认返回 undefined。

### 至少可以说出三种判断 JavaScript 数据类型的方式，以及他们的优缺点，如何准确的判断数组类型

1. typeof：返回一个字符串，表示未经计算的操作数的类型
   - 对于基本类型，除 null 以外，均可以返回正确的结果。
   - 对于引用类型，除 function 以外，一律返回 object 类型。
   - 对于 null ，返回 object 类型。
   - 对于 function 返回  function 类型。
2. Instanceof：测试构造函数的prototype属性是否出现在对象的原型链中的任何位置

```javascript
A instanceof B

A.__proto__...  是否存在 B.prototype

function _instanceof(A, B) {
    var O = B.prototype;// 取B的显示原型
    A = A.__proto__;// 取A的隐式原型
    while (true) {
        //Object.prototype.__proto__ === null
        if (A === null)
            return false;
        if (O === A)// 这里重点：当 O 严格等于 A 时，返回 true
            return true;
        A = A.__proto__;
    }
}
```

缺点：[instanceof和多全局对象(多个frame或多个window之间的交互)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof)

3. Object.prototype.toString.call：

   每一个继承 Object 的对象都有 `toString` 方法，如果 `toString` 方法没有重写的话，会返回 `[Object type]`，其中 type 为对象的类型，常用于判断浏览器内置对象。

判断数组类型：

Array.isArray：ES5新增方法，可以检测出 iframes，如果不存在则可以使用Object.prototype.toString.call来进行替代

```javascript
if (!Array.isArray) {
  Array.isArray = function(arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
  };
}
```

### 可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用

**发生场景：**

涉及隐式转换最多的两个运算符 + 和 ==。

+运算符即可数字相加，也可以字符串相加。== 不同于===，故也存在隐式转换。- * / 这些运算符只会针对number类型，故转换的结果只能是转换成number类型。

**隐式转换中主要涉及到三种转换：**

1、将值转为原始值，ToPrimitive()。

2、将值转为数字，ToNumber()。

3、将值转为字符串，ToString()。

### JavaScript 小数精度丢失，大数问题

**精度丢失：**

用一句话来概括就是，计算机中用二进制来存储小数，而大部分小数转成二进制之后都是无限循环的值，因此存在取舍问题，也就是精度丢失。

解决方案：

1. 若只是展示结果，可使用 Number 对象的 toFixed 和 parseFloat 方法

```javascript
function formatNum(num, fixed = 10) {    
  return parseFloat(a.toFixed(fixed));
}

var a = 0.1 + 0.2;
console.log(formatNum(a)); //0.3
```

2. 若需要进行浮点数加减乘除运算，在小于 Number.MAXSAFEINTEGER 范围的整数是可以被精确表示出来的，所以可以先把小数转化为整数，运算得到结果后再转化为对应的小数

```javascript
function add(num1, num2) {  
  var decimalLen1 = (num1.toString().split('.')[1] || '').length; 
  //第一个参数的小数个数  
  var decimalLen2 = (num2.toString().split('.')[1] || '').length; 
  //第二个参数的小数个数  
  var baseNum = Math.pow(10, Math.max(decimalLen1, decimalLen2));  
  return (num1 * baseNum + num2 * baseNum) / baseNum;
}

console.log(add(0.1 , 0.2)); //0.3
```

**最大安全整数**：

JavaScript 中的基本数据类 Number 是双精度浮点数，它可以表示的最大安全范围是正负9007199254740991，也就是 2^53 - 1。

对安全整数范围以外的整数（即从`Number.MIN_SAFE_INTEGER`到`Number.MAX_SAFE_INTEGER`）的任何计算可能会失去精度

[超出安全限制的数字计算](https://www.cnblogs.com/wangmeijian/p/9217352.html)

## 原型和原型链

### 理解原型设计模式以及 JavaScript 中的原型规则

定义：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象

JavaScript 中的原型规则不再赘述

### instanceof 的底层实现原理，手动实现一个 instanceof

```javascript
function _instanceof(A, B) {
    var O = B.prototype;// 取B的显示原型
    A = A.__proto__;// 取A的隐式原型
    while (true) {
        //Object.prototype.__proto__ === null
        if (A === null)
            return false;
        if (O === A)// 这里重点：当 O 严格等于 A 时，返回 true
            return true;
        A = A.__proto__;
    }
}
```

### 实现继承的几种方式以及他们的优缺点

组合继承，原型继承，构造函数继承，混合继承，增强原型继承...

详细看 js-source 中的 inherit 文件夹

### 可以描述 new 一个对象的详细过程，手动实现一个 new 操作符

```javascript
function myNew() {
  // 创建空对象
  let obj = new Object();

  // 获取构造函数
  let Constructor = [].shift.call(arguments);

  // 链接原型
  obj.__proto__ = Constructor.prototype;

  // 调用父构造函数继承
  let res = Constructor.apply(obj, arguments);

  // 只返回对象 优先级: 构造函数返回 > 新创建
  return res instanceof Object ? res : obj;
}

```

### 理解 es6 class 构造以及继承的底层实现原理

假设我们有这样的一个类

```javascript
class People{
  constructor(name,age){
     this.name = name;
     this.age = age;
  }
     
  static see(){ 
    alert("how are you") 
  }  
}

```

那么对应的ES5代码为

```javascript
let People = function () { //第①步，创建People函数

  function People(name, age) { //第②步，理解constructor就是指向People，People挂载着name和age两个属性
    this.name = name;
    this.age = age;
  }

  //将静态和动态的方法分别挂载在People的原型和People上。   
  creatClass(People, [{
    key: "say",
    value: function () {
      console.log(123)
    }
  }], [{
    key: "see",
    value: function () {
      alert("how are you")
    }
  }])

  return People;
}

//这里的Constructor就是指的People  
let creatClass = function ({
    return function (Constructor, protoProps, staticProps) {
      //有原型上的方法挂载People.prototype上
      if (protoProps) {
        defineProperties(Constructor.prototype, protoProps)
      }
      //有People对象上的方法挂载People上
        defineProperties(Constructor, staticProps)
      }
  }

  //定义对象属性     
  let defineProperties = function (target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
})

```

### 持续更新...
