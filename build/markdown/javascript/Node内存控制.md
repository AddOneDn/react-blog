# Node内存控制

基于无阻塞，事件驱动建立的Node服务，具有内存消耗低的优点，非常适合处理海量的网络请求，那么在Node中是如何高效的使用内存的呢？

# V8的垃圾回收机制和内存限制

在Node中，对于性能敏感的服务器端程序，内存管理的好坏，垃圾回收状况是否优良等，都与Node的Javascript执行引擎V8息息相关

## V8的内存限制

在Node中通过JavaScript使用内存时就会发现只能使用部分内存(64位系统下约为1.4GB，32位系统下约为0.7GB)，在这种限制下，导致Node无法直接操作大内存对象。

造成这种问题的主要原因在于Node基于V8构建，所以在Node中使用的JavaScript对象基本上都是通过V8自己的方式来进行分配和管理的。这套管理机制在浏览器下使用起来绰绰有余，但是在Node中限制了开发者随心所欲使用大内存的想法

## V8的对象分配

V8中，所有的JavaScript对象都是通过堆来分配的。

```javascript
$ node
> process.memoryUsage()
{ rss: 22163456,
  heapTotal: 7708672, // 已申请到的堆内存
  heapUsed: 4947432, // 当前使用的堆内存
  external: 16822 }
```

当我们在代码中声明变量并且赋值时，所使用对象的内存就分配在堆中。如果已经申请的堆空间内存不够就继续申请堆内存，直到堆的大小超过V8的限制为止

> V8为什么要限制堆的大小？

表层原因是V8最初为浏览器设置，其内存绰绰有余。深层原因是V8的垃圾回收机制的限制，以1.5GB的辣鸡回收堆内存为例，V8做一次小的垃圾回收需要50ms以上，做一次非增量的垃圾回收甚至要1s以上，并且这还会导致**JavaScript线程暂停**，这种时间开销带来的性能和响应能力的直线下降，是前后端都无法接受的。

如果你想打开限制也是可以的

```javascript
node --max-old-space-size=1700 index.js // MB 设置老生代

node --max-new-space-size=1700 index.js // KB 设置新生代
```

该设置在V8初始化时生效，后续无法动态改变

## V8的垃圾回收机制

现代的垃圾回收算法中按照对象的存活时间将内存的垃圾回收进行不同的分代

### V8的内存分代

在V8中，主要将内存分为新生代和老生代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。V8堆的整体大小就是新生代加上老生代的内存空间。

**不同操作位数电脑上分代内存大小**

|        | 32位  | 64位   |
| ------ | ----- | ------ |
| 新生代 | 16MB  | 32MB   |
| 老生代 | 700MB | 1400MB |
| V8堆   | 732MB | 1464MB |

V8堆内存: 4 * reserved_semispace_ size_ + max_old_generation_size_

### Scavenge算法

新生代中的对象主要通过Scavenge算法进行垃圾回收，在Scavenge的具体实现中，主要采用了Cheney算法，这是一种采用复制的方式实现的垃圾回收算法。

它将堆内存一分为二，每一部分空间称为semispace，其中只有一个处于使用中，另一个处于闲置状态。使用状态的semispace空间称为From空间，另一个称为To空间。当我们**分配对象**时，先是在From空间中进行分配。当我们**垃圾回收**时，会检查From空间中的存活对象，然后将他们复制到To空间中，而非存活对象占用的空间将会被释放，复制完成后，From空间和To空间进行**角色互换**。简而言之，其主要过程就是通过将存活对象在两个semispace之间进行**复制**。

Scavenge的缺点是只能使用堆内存的一半，但是其只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上有优异的表现。

由于Scavenge是牺牲空间换取时间的算法，所以无法应用到所有的垃圾回收中，但是因为新生代中对象的生命周期较短，所以它十分适合应用到新生代中。

[![FYkIa9.md.jpg](https://s1.ax1x.com/2018/12/11/FYkIa9.md.jpg)](https://imgchr.com/i/FYkIa9)

一个对象经过多次复制依然存活时，它将会被认为是生命周期较长的对象。这种生命周期较长的对象随后会被移动到老生代中，采用新的算法进行管理，这个过程称为**晋升**

在单纯的Scavenge过程中，From中的存活对象直接复制到To中，然后进行角色互换。但是在分代式的垃圾回收中，进行复制之前要进行检查，对符合条件的对象进行晋升

- 是否经历过Scavenge回收
- To空间内存占比超过限制（25%）

### Mark-Sweep & Mark-Compact

对于老生代中的对象，由于存活对象所占比重较大，采用Scavenge会有两个问题：

- 存活对象较多，复制存活对象的效率将会降低
- 老生代空间较大，浪费一半空间损失太大

为此，V8在老生代中主要采用了Mark-Sweep和Mark-Compact相结合的方式进行垃圾回收

Mark-Sweep是标记清除的意思，它在标记阶段遍历堆中所有对象，并标记活着的对象，然后只清除没有标记的对象。

> 我们可以将标记看作为图遍历

Scavenge只复制活的对象，Mark-Sweep只清理死亡对象，活对象在新生代中占小部分，死对象在老生代中占少部分，这就是两种回收方式能高效处理的原因

> 但是Mark-Sweep在进行一次标记清除回收后，内存空间会出现不连续状态。这样如果要分配一个大对象，那么此时所有的碎片空间都无法完成此次分配，提前出发垃圾回收，但是这是不必要的。

为了解决Mark-Sweep的内存碎片问题，Mark-Compact被提出来。Mark-Compact是标记清理的意思，是在Mark-Sweep基础上演变而来的。它们的差别在于，对象被标记为死亡后，将活着的对象往一端移动，移动完成后清理边界外的内存。

| 回收算法     | Mark-Sweep   | Mark-Compact | Scavenge           |
| ------------ | ------------ | ------------ | ------------------ |
| 速度         | 中等         | 最慢         | 最快               |
| 空间开销     | 少（有碎片） | 少（有碎片） | 双倍空间（无碎片） |
| 是否移动对象 | 否           | 是           | 是                 |

V8主要使用Mark-Sweep，在空间不足以对从新生代晋升过来的对象进行分配时才使用Mark-Compact

### Incremental Marking

为了避免出现JavaScript应用逻辑与垃圾回收期看到的不一致的情况，垃圾回收的3种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再回复执行应用逻辑，这种行为被称为**全停顿**(stop-the-world)。在V8的分代式垃圾回收中，新生代中存活对象较少，全停顿没有太大影响，但是在老生代汇总就会造成较长的延迟，需要改善。

为了降低垃圾回收带来的停顿时间，V8先从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记(Incremental Marking)，也就是拆分为许多步进，每做完一“步进”就让JavaScript应用逻辑执行一小会，垃圾回收与应用逻辑交替执行直到标记阶段完成。

> 经过增量标记改进，垃圾回收的最大停顿时间可以减少到原本的1/6左右。
>
> 但是增量标记不是没有代价的。应用程序必须通知垃圾收集器关于改变对象图的所有操作。

V8后续还引入了延迟清理(Lazy Sweeping)和增量式整理(Incremental Compaction)，让清理和整理都做也变成增量式的，同时计划引入[并行标记](https://www.oschina.net/translate/v8-javascript-engine)与并行清理。

### Lazy Sweeping

发生在增量标记完成后，此时所有对象都已经被标记完毕，堆已经确切知道要回收多少内存，但是不必一次回收全部，可以采用延迟清理的方法，根据需要来回收部分内存。全部垃圾内存回收完毕后，整个**增量标记-延迟清理**的 周期结束。

## 小结

想要高性能的执行效率，需要注意让垃圾回收尽量少地进行，尤其是全堆垃圾回收。
