# Node模块机制

CommonJS规范为JavaScript制定了一个美好的愿景：希望JavaScript能够在任何地方运行。

## 出发点

对于原来的JavaScript自身来说：

- 没有模块系统
- 标准库较少
- 没有标准接口
- 缺乏包管理系统

## 模块规范

### 模块引用

```javascript
var package = require('package');
```

### 模块定义

在模块中，上下文提供require方法来引入外部模块，提供exports**对象**来导出当前模块的方法或者变量。在模块中，存在一个module对象，代表模块自身，且上面有一个exports属性，它和exports指向同一个对象，即`module.exports = exports = {}`

### 模块标识

模块标识就是你传递给require方法的参数，必须是**小驼峰**命名的字符串，或者以`.`,`..`开头的相对/绝对路径，可以不添加文件名后缀。每个模块具有独立的空间，他们互不干扰。

## 模块实现

引入模块分为3个步骤：

1. 路径分析
2. 文件定位
3. 编译执行

模块分为两类，一类是Node提供的**核心模块**，一类是用户编写的**文件模块**。

- **核心模块**在Node源代码的编译过程中，编译进了**二进制执行文件**。在Node进程启动时，部分核心模块就被直接**加载进内存**，所以这部分模块被引入时就可以省略掉文件定位和编译执行， 并且在路径分析中优先判断，它的加载速度是最快的
- **文件模块**则是在运行时动态加载，需要完整的路径分析，文件定位，编译执行过程，速度比核心模块慢

### 缓存加载

Node对引入过的模块都会进行缓存，缓存的是编译和执行之后的对象。require方法对相同模块的二次加载都一律采用缓存优先的方式，这是**第一优先级**。但是核心模块的缓存检查优先于文件模块的缓存检查。

### 路径分析/模块定位

1. 模块标识符分析

模块标识符在Node中主要分为以下几类：

- 核心模块，如http，fs，path等
  - 核心模块的优先级仅次于缓存加载，并且你无法加载一个与核心模块标识符相同的自定义模块。
- `.`或`..`开始的相对路径文件模块
  - 以`.`或`..`开始的标识符都被当做文件模块处理。在分析模块时，require会将路径转化为真实路径作为索引，然后将编译执行后的结果存放到缓存中。
- 以`/`开始的绝对路径文件模块
  - 同上
- 非路径形式的文件模块，如自定义的connect模块
  - 自定义模块指的是非核心模块，也不是路径形式的标识符。它是一种特殊的文件模块，可能是一个文件或者包的形式，是查找最费时的。

模块路径是Node在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组，其生成规则：

- 当前文件目录下的node_modules目录
- 父目录下的node_modules目录
- 父目录的父目录下的node_modules目录
- 沿路径向上逐级递归，直到根目录下的node_modules目录

Node会逐个尝试模块路径中的路径，直到找到目标文件。当前文件的路径越深，模块查找越耗时，加载速度最慢。

1. 文件定位

- 扩展名分析

Node会按`.js`，`.json`，`.node`的次序补足扩展名。尝试的过程中要调用fs模块同步阻塞式地判断文件是否存在，所以如果是`.json`或`.node`文件，在传递给require的标识符中要带上扩展名来加速。

- 目录分析和包

分析标识符的过程中，require通过分析文件扩展名后，可能没有查找到对应文件，但却得到一个目录，此时Node会将目录当做一个包来处理。Node会在当前目录下查找package.json，通过JSON.parse解析出包描述对象，从中取出main属性指定的文件名进行定位。

如果main属性指定的文件名错误，或者没有package.json，Node会将index当做默认文件名，然后依次查找index.js，index.json，index.node

如果在目录分析过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找，若最后没有找到则抛出异常。

## 模块编译

对于不同的文件扩展名，其载入方法也有所不同：

- **.js文件**。通过fs模块同步读取文件后编译执行
- **.node文件**。用C/C++编写的扩展文件，通过dlopen方法加载后编译生成的文件
- **.json文件**。通过fs模块同步读取文件后，用JSON.parse解析返回结果
- **其余扩展名文件**。他们都被当做.js文件载入

### JavaScript模块的编译

在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装`(function(exports, require, module, _filename, _dirname))`，进行作用域隔离，并且通过vm原生模块的runInThisContext方法执行(类似eval，只是具有明确上下文，不污染全局)，返回一个具体的function对象。最后将当前模块对象的exports属性，require方法，module(模块自身)，以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function执行。

exprts属性上任何方法和属性都可以被外部调用到，但模块内的其余变量和属性不可调用

### C/C++模块的编译

Node调用process.dlopen方法进行加载和执行。实际上`.node`的模块文件并不需要编译，它是编写C/C++模块之后编译生成的，所以这里只有加载和执行过程。在执行的过程中，模块的exports对象与.node模块产生联系，返回给调用者。

C/C++模块效率较高，但是编写门槛也较高。

### JSON文件的编译

`.json`文件的编译是3中编译方式中最简单的。Node利用fs模块同步读取JSON文件的内容之后，调用JSON.parse方法得到对象，然后将它赋给模块对象的exports，供外部调用。